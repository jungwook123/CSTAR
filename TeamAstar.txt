#include <stdio.h>
#include <stdlib.h>
#include <Windows.h>
#include <conio.h>
#include <math.h>

#define UP 72
#define DOWN 80
#define LEFT 75
#define RIGHT 77

void gotoxy(int x, int y) {
    COORD pos = { (SHORT)x, (SHORT)y };
    SetConsoleCursorPosition(GetStdHandle(STD_OUTPUT_HANDLE), pos);
}

int dx[4] = { 0, 1, 0, -1 }, dy[4] = { -1, 0, 1, 0 };

int field[1001][1001] = {
    {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15},
    {'A', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    {'B', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    {'C', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    {'D', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    {'E', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    {'F', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    {'G', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    {'H', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    {'I', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    {'J', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    {'K', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    {'L', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    {'M', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    {'N', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    {'O', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}
};

typedef struct {
    int x, y;
    int g, h;
    int parent_x, parent_y;
} Node;

int visited[20][20];
Node parent[20][20];

int goalX = -1, goalY = -1;

int heuristic(int x1, int y1, int x2, int y2) {
    return abs(x1 - x2) + abs(y1 - y2);
}

void draw_path(int gx, int gy) {
    int x = gx, y = gy;
    while (!(x == 1 && y == 1)) {
        int px = parent[y][x].parent_x;
        int py = parent[y][x].parent_y;
        if (field[y][x] == 0) field[y][x] = '*';
        x = px; y = py;
    }
}

void A_star(int sx, int sy, int gx, int gy) {
    memset(visited, 0, sizeof(visited));
    memset(parent, -1, sizeof(parent));

    Node open[1000];
    int openSize = 0;
    Node start;
    start.x = sx;
    start.y = sy;
    start.g = 0;
    start.h = heuristic(sx, sy, gx, gy);
    start.parent_x = -1;
    start.parent_y = -1;

    open[openSize++] = start;

    while (openSize > 0) {
        
        int idx = 0;
        for (int i = 1; i < openSize; i++) {
            if (open[i].g + open[i].h < open[idx].g + open[idx].h) idx = i;
        }

        Node cur = open[idx];
        open[idx] = open[--openSize];

        if (visited[cur.y][cur.x]) continue;
        visited[cur.y][cur.x] = 1;
        parent[cur.y][cur.x] = cur;

        if (cur.x == gx && cur.y == gy) {
            draw_path(gx, gy);
            return;
        }

        for (int d = 0; d < 4; d++) {
            int nx = cur.x + dx[d];
            int ny = cur.y + dy[d];

            if (nx < 1 || nx > 15 || ny < 1 || ny > 15) continue;
            if (field[ny][nx] == -1 || visited[ny][nx]) continue;

            Node next = { nx, ny, cur.g + 1, heuristic(nx, ny, gx, gy), cur.x, cur.y };
            open[openSize++] = next;
        }
    }
}

void print_field() {
    int i, j;
    for (i = 0; i <= 15; i++) {
        for (j = 0; j <= 15; j++) {
            SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), 7);
            if (field[i][j] >= 1 && field[i][j] <= 15)
                printf("%2d ", field[i][j]);
            else if (field[i][j] == 0)
                printf("%2c ", '-');
            else if (field[i][j] == -1)
                printf("%2c ", 'X');
            else if (field[i][j] == -2)
            {
                SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), 10);
                printf("%2c ", 'O');
                SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), 7);
            }
                
            else if (field[i][j] == -3) {
                SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), 14);
                printf("%2c ", 'X');

            }
            else if (field[i][j] == '*') {
                SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), 10);
                printf("%2c ", '*');
                SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), 7); 
            }
            else if (field[i][j] == '@')
                printf("%2c ", '@');
            else
                printf("%2c ", field[i][j]);
        }
        printf("\n");
    }
}

int main() {
    system("cls");

    int x = 7;
    char y = 'H';
    int running = 1;

    while (running) {
        field[1][1] = -2;

        int original = field[y - 'A' + 1][x];
        field[y - 'A' + 1][x] = -3;

        gotoxy(0, 0);
        print_field();

        field[y - 'A' + 1][x] = original;

        printf("방향키 이동 | ENTER: 장애물 배치 | SPACE: 목표(@) 설정 | /: 요소 삭제 | \\: 필드 초기화 ESC: 종료\n");

        int key = _getch();
        switch (key) {
        case LEFT: if (x > 1) x--; break;
        case RIGHT: if (x < 15) x++; break;
        case UP: if ((y - 'A') > 0) y--; break;
        case DOWN: if ((y - 'A') < 14) y++; break;
        case 27: running = 0; break; // ESC
        case 13: // ENTER
            if (field[y - 'A' + 1][x] == 0 || field[y - 'A' + 1][x] == '*') {
                field[y - 'A' + 1][x] = -1;

                // 기존 경로를 초기화
                for (int i = 1; i <= 15; i++)
                    for (int j = 1; j <= 15; j++)
                        if (field[i][j] == '*')
                            field[i][j] = 0;

                // A* 알고리즘 재실행
                if (goalX != -1 && goalY != -1)
                    A_star(1, 1, goalX, goalY);
            }
            break;
        case 32: // SPACE
            if (field[y - 'A' + 1][x] != -1){
                if (goalX != -1 && goalY != -1 && field[goalY][goalX] == '@')
                    field[goalY][goalX] = 0; // 이전 목표 초기화

                goalX = x;
                goalY = y - 'A' + 1;
                field[goalY][goalX] = '@';

                
                for (int i = 1; i <= 15; i++)
                    for (int j = 1; j <= 15; j++)
                        if (field[i][j] == '*')
                            field[i][j] = 0;

                A_star(1, 1, goalX, goalY);}
            break;
        case 47:  // '/' 키 입력
            if (field[y - 'A' + 1][x] == -1) {
                // 장애물(-1) 제거
                field[y - 'A' + 1][x] = 0;
            } else if (field[y - 'A' + 1][x] == '@') {
                // 목표(@) 제거
                field[y - 'A' + 1][x] = 0;
                goalX = -1; // 목표 초기화
                goalY = -1;

                // 기존 경로 초기화
                for (int i = 1; i <= 15; i++)
                    for (int j = 1; j <= 15; j++)
                        if (field[i][j] == '*')
                            field[i][j] = 0;
            }

            // 장애물만 제거하면 경로를 다시 계산
            if (goalX != -1 && goalY != -1) {
                for (int i = 1; i <= 15; i++)
                    for (int j = 1; j <= 15; j++)
                        if (field[i][j] == '*')
                            field[i][j] = 0;

                A_star(1, 1, goalX, goalY);
            }
            break;
        case '\\': // '\' 키 입력
            // field 배열 초기화
            for (int i = 1; i <= 15; i++)
                for (int j = 1; j <= 15; j++)
                    field[i][j] = 0;

            // 목표 및 경로 정보 초기화
            goalX = -1;
            goalY = -1;

            // 시작 지점 다시 설정
            field[1][1] = -2;

            break;
        }
        
    }
    return 0;
}
// 요소 삭제/필드 초기화 기능 추가, 경로 위에 장애물을 추가 가능하도록 변경